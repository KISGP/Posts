---
title: 基本类型
tags:
  - Rust
---

> [!tip]
>
> Rust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，但在它无法推导出变量类型时，需要手动去给予一个类型标注。

# 数值类型

## 基本类型

有符号整数：`i8`, `i16`, `i32`, `i64`, `isize`

无符号整数：`u8`, `u16`, `u32`, `u64`, `usize`

> isize、usize 的位数则视架构而定，在 32 位架构上为 32 位，在 64 位架构上为 64 位，适合用于表示内存地址、数组索引等需要根据系统架构来决定大小的场景。

浮点数：`f32`, `f64`

> [!note]
>
> 有符号/无符号整数，浮点数的具体内容可以查看 [计算机组成原理/数据的表示和运算](../../../计算机基础/408/计算机组成原理/2_数据的表示和运算.md)。

> [!warning]
>
> 浮点数类型是基于二进制实现的，因此某些数字无法精确表示（例如 0.1）。
>
> ```rust
> fn main() {
> 	let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
> 	let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);
> 	println!("0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());// 0.1 + 0.2: 3e99999a
> 	println!("0.3: {:x}", (abc.2).to_bits());// 0.3: 3e99999a
> 	
>   println!("0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());// 0.1 + 0.2: 3fd3333333333334
> 	println!("0.3: {:x}", (xyz.2).to_bits());// 0.3: 3fd3333333333333
> }
> ```

## NaN

`NaN` (Not a Number)是浮点数的一种特殊值，表示一个无效或无法定义的数值结果。它常见于浮点数运算中，如零除以零、无效的平方根等情况。`NaN` 不等于任何值，包括自己。可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN` 。

```rust
fn main() {
   let x: f64 = 0.0 / 0.0; // 结果是 NaN
   let y: f64 = f64::sqrt(-1.0); // 结果是 NaN

   println!("{}", x.is_nan()); // true
   println!("{}", y.is_nan()); // true

   println!("x == x: {}", x == x); // x == x: false
   println!("x == NaN: {}", x == y); // x == NaN: false
}
```

## 序列

序列(Range)用来生成连续的数值。序列只允许用于数字或字符类型。

```rust
fn main() {
    for i in 1..5 {
        println!("{}", i); // 1 ...... 4
    }
    for i in 1..=5 {
        println!("{}", i);// 1 ...... 5
    }
    for i in 'a'..='z' {
        println!("{}", i);// a ...... z
    }
}
```

# 单元类型

单元类型即 `()` ，其唯一的值也是 `()`，通常表示“没有值”或“什么都没有”。

很多时候，Rust 中的函数如果没有返回值，它的返回类型就是单元类型 `()`。即使函数没有显式返回 `()`，Rust 也会隐式地认为它返回了 `()`。

```rust
fn main() {
   let a = (); // 单元类型的值
   println!("{:?}", a); // 输出：()
   
   // 一个没有返回值的函数
   let result = do_nothing();
   println!("{:?}", result); // 输出：()
}

fn do_nothing() -> () {
   // 什么都不做，隐式返回单元类型 ()
}
```

使用场景：

- **函数返回值**：函数如果不需要返回任何有意义的结果，可以显式返回 `()`。例如，很多 Rust 中的事件处理函数、回调函数、或者某些状态修改函数通常返回 `()`，表示操作已经完成但没有结果。
- **占位符**：有时，`()` 用作占位符，表示某个地方没有具体的值或没有需要关注的数据。

# 语句和表达式

**语句**是执行某个操作的代码块，它通常没有返回值。它告诉程序去做某件事，但不产生一个可以进一步操作的值。

```rust
let x = 5;  // 这是一个语句，x 被赋值为 5

println!("Hello, world!"); // 这是一个语句，调用了 println 函数

if x > 5 {
    println!("x is greater than 5");
} // 这是一个语句，控制条件执行
```

**表达式**是产生一个值的代码块。它可以被计算出一个值，并且这个值可以被赋值、返回或者传递给其他表达式。

```rust
5 // 这是一个表达式，返回 5
"hello" // 这是一个表达式，返回字符串 "hello"
3 + 4 // 这是一个表达式，返回 7

fn add(x: i32, y: i32) -> i32 {
    x + y // 这里的 `x + y` 是一个表达式，返回计算结果
}

let x = if condition { 5 } else { 10 }; // 这是一个表达式，条件结果决定了 x 的值
```

> [!important]
>
> 表达式没有 `;` 结尾，`;` 结尾的是语句。

# 函数

函数是一段封装好的代码块，用来执行特定的任务。函数接收输入（参数）、执行一系列操作，并可能返回一个值。

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y // 返回 x 和 y 的和
}

fn main() {
    let result = add(5, 3); // 调用函数
    println!("The result is {}", result); // 输出结果 8
}
```

> [!tip]
>
> Rust 不关心我们在哪里定义了函数，只要有定义即可。
>
> 函数的参数可以有多个，并且每个参数都要指定类型。参数是函数外部传入的值，它们的作用域仅限于函数体内。

