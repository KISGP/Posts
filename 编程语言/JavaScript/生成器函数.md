---
title: 生成器函数
tags:
  - JS 
---

# 什么是生成器函数

在 JavaScript 中，生成器函数是一种特殊类型的函数，它可以暂停执行并在随后恢复执行。生成器函数使用 `function*` 语法定义，并且可以使用 `yield` 关键字来暂停函数的执行。

当生成器函数被调用时，并不会立即执行函数体，而是返回一个**生成器对象**。通过调用生成器对象的 `next()` 方法，可以逐步执行生成器函数的代码，直到遇到 `yield` 关键字或函数结束。

```js
function* generatorFunction() {
  yield 'Hello';
  yield 'World';
  return '!';
}

const generator = generatorFunction();

console.log(generator.next().value); // 输出: Hello
console.log(generator.next().value); // 输出: World
console.log(generator.next().value); // 输出: !
console.log(generator.next().value); // 输出: undefined
```

在这个例子中，生成器函数 `generatorFunction` 定义了三个步骤的执行，每次调用 `next()` 方法时，生成器的执行都会暂停在 `yield` 关键字处，并返回 `yield` 后面的值。最后，当生成器函数执行完毕时，会返回 `return` 语句的值。

> [!tip]
>
> `function* f(…)` 和 `function *f(…)` 这两种语法都是对的。

# Generator

在 JavaScript 中，生成器函数返回的生成器对象符合迭代器协议和可迭代协议。这意味着生成器对象既是迭代器，也是可迭代对象。

具体来说，生成器对象具有以下特性：

1. **迭代器协议**：生成器对象实现了一个 `next()` 方法，该方法返回一个具有 `value` 和 `done` 属性的对象。`value` 表示当前的值，`done` 表示迭代是否完成。
2. **可迭代协议**：生成器对象实现了一个 `iterator` 方法，也就是 `Symbol.iterator` 方法，该方法返回生成器对象自身。这使得生成器对象可以用于 `for...of` 循环等迭代上下文中。

```js
const generator = generatorFunction();

// 生成器对象作为迭代器使用
console.log(generator.next()); // { value: 'Hello', done: false }
console.log(generator.next()); // { value: 'World', done: false }
console.log(generator.next()); // { value: '!', done: true }
console.log(generator.next()); // { value: undefined, done: true }

// 生成器对象作为可迭代对象使用
for (const value of generatorFunction()) {
  console.log(value);
}
// 输出:
// Hello
// World
```

> [!tip]
>
> 生成器函数中的 `return` 语句的值不会被 `for...of` 循环打印出来。
>
> 在 JavaScript 中，生成器函数中的 `return` 语句不会被 `for...of` 循环捕获到。`for...of` 循环只会迭代 `yield` 关键字生成的值，并且在 `done` 属性为 `true` 时停止迭代。

# Generator Composition

生成器组合(Generator Composition)是指在一个生成器函数中调用另一个生成器函数，从而将多个生成器的输出组合在一起。这通常使用 `yield*` 关键字来委托对另一个生成器的调用。

通过生成器组合可以创建更复杂的迭代逻辑，将多个生成器的输出组合成一个单一的迭代序列。

```js
function* generatorA() {
  yield 'Hello';
  yield 'from';
}

function* generatorB() {
  yield 'Generator';
  yield 'B';
}

function* combinedGenerator() {
  yield* generatorA();
  yield* generatorB();
  yield '!';
}

const generator = combinedGenerator();

for (const value of generator) {
  console.log(value);
}
// 输出:
// Hello
// from
// Generator
// B
// !
```

# yield 双向路

`yield` 是一条双向路，这意味着不仅可以从生成器函数中产出值，还可以向生成器函数发送值。

当生成器函数执行到 `yield` 表达式时，它会暂停执行并返回 `yield` 后面的值。此时，生成器函数的状态被保留。你可以通过调用生成器对象的 `next()` 方法继续执行生成器函数，并且可以向 `next()` 方法传递一个参数，这个参数会成为 `yield` 表达式的返回值。

```js
function* twoWayGenerator() {
  const first = yield 'First yield';
  console.log('First received:', first);
  const second = yield 'Second yield';
  console.log('Second received:', second);
  return 'Finished';
}

const generator = twoWayGenerator();

console.log(generator.next().value); // 输出: First yield
console.log(generator.next('First value').value); // 输出: First received: First value
                                                 // 输出: Second yield
console.log(generator.next('Second value').value); // 输出: Second received: Second value
                                                   // 输出: Finished
```

在这个示例中：

1. 第一次调用 `generator.next()`，生成器函数执行到第一个 `yield` 并返回 `'First yield'`。
2. 第二次调用 `generator.next('First value')`，生成器函数继续执行，并将 `'First value'` 作为第一个 `yield` 表达式的返回值。
3. 第三次调用 `generator.next('Second value')`，生成器函数继续执行，并将 `'Second value'` 作为第二个 `yield` 表达式的返回值。

通过这种方式，`yield` 表达式可以在生成器函数和调用者之间传递值，实现双向通信。

# generator.throw

生成器对象的 `throw` 方法可以用来向生成器内部抛出一个错误。使用 `throw` 方法时，可以在生成器函数暂停执行的地方捕获这个错误，从而实现错误处理。

```js
function* generatorFunction() {
  try {
    yield 'First yield';
  } catch (error) {
    console.log('Caught an error:', error);
  }
  yield 'Second yield';
  return 'Finished';
}

const generator = generatorFunction();

console.log(generator.next().value); // 输出: First yield
console.log(generator.throw(new Error('Something went wrong')).value); // 输出: Caught an error: Error: Something went wrong
                                                                      // 输出: Second yield
console.log(generator.next().value); // 输出: Finished
```

在这个示例中：

1. 第一次调用 `generator.next()`，生成器函数执行到第一个 `yield` 并返回 `'First yield'`。
2. 调用 `generator.throw(new Error('Something went wrong'))`，向生成器函数抛出一个错误。这个错误会被生成器函数内部的 `try...catch` 语句捕获，并输出错误信息。生成器函数继续执行并返回 `'Second yield'`。
3. 最后一次调用 `generator.next()`，生成器函数执行完毕并返回 `'Finished'`。

# generator.return

生成器对象的 `return` 方法用于终止生成器的执行，并可选地返回一个指定的值。调用 `return` 方法会使生成器立即完成（即 `done` 属性变为 `true`），并返回一个带有指定返回值的对象。

```js
function* generatorFunction() {
  yield 'First yield';
  yield 'Second yield';
  yield 'Third yield';
  return 'Finished';
}

const generator = generatorFunction();

console.log(generator.next().value); // 输出: First yield
console.log(generator.return('Early exit').value); // 输出: Early exit
console.log(generator.next().value); // 输出: undefined
console.log(generator.next().done); // 输出: true
```

在这个示例中：

1. 第一次调用 `generator.next()`，生成器函数执行到第一个 `yield` 并返回 `'First yield'`。
2. 调用 `generator.return('Early exit')`，生成器立即完成，并返回指定值 `'Early exit'`。生成器的 `done` 属性变为 `true`。
3. 再次调用 `generator.next()`，由于生成器已经完成，返回的对象的 `value` 属性为 `undefined`，`done` 属性为 `true`。

